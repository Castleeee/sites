---
title: GO的PPT
date: 2019/2/3
categories: backEnd
tags:
- GO
- 语言基础
- 搬运
- 后端
---

<div align= center><h1>简介🐋</h1></div>

<div align=center>
类型安全 和 内存安全<br/>
以非常直观和极低代价的方案实现 高并发<br/>
快速编译,同时解决C语言中头文件太多的问题<br/>
为多核计算机提供性能提升的方案<br/>
高效的垃圾回收机制<br/>
UTF-8编码支持<br/>
</div>

## 乱七八糟交代的
### 命令
在命令行或终端输入go即可查看所有支持的命令<br/>

Go常用命令简介

- go get：获取远程包（需 提前安装 git或hg）
- go run：直接运行程序
- go build：测试编译，检查是否有编译错误
- go fmt：格式化源码（部分IDE在保存时自动调用）
- go install：编译包文件并编译整个程序
- go test：运行测试文件
- go doc：查看文档（CHM手册）
### 关键字保留
// ：单行注释<br/>
/* */：多行注释<br/>

<a href="http://www.runoob.com/go/go-basic-syntax.html">这里</a>
### 程序结构
Go程序是通过 package 来组织的（与python类似）<br/>
只有 package 名称为 main 的包可以包含 main 函数<br/>
一个可执行程序 有且仅有 一个 main 包<br/>

通过 import 关键字来导入其它非 main 包<br/>
通过 const 关键字来进行常量的定义<br/>
通过在函数体外部使用 var 关键字来进行全局变量的声明与赋值<br/>
通过 type 关键字来进行结构(struct)或接口(interface)的声明<br/>
通过 func 关键字来进行函数的声明<br/>
## 数据类型查询
<a href="http://www.runoob.com/go/go-data-types.html">传送门</a>
## 常量
- 常量的定义
  - 常量的值在编译时就已经确定
  - 常量的定义格式与变量基本相同
  - 等号右侧必须是常量或者常量表达式
  - 常量表达式中的函数必须是内置函数
- 常量的初始化规则与枚举
  - 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式
  - 使用相同的表达式不代表具有相同的值
  - iota是常量的计数器，从0开始，组中每定义1个常量自动递增1
  - 通过初始化规则与iota可以达到枚举的效果
  - 每遇到一个const关键字，iota就会重置为0

## if
- 判断语句if
  - 条件表达式没有括号
  - 支持一个初始化表达式（可以是并行方式）
  - 左大括号必须和条件语句或else在同一行
  - 支持单行模式
  - 初始化语句中的变量为block级别，同时隐藏外部同名变量
  - 1.0.3版本中的编译器BUG
## for
- 循环语句for
  - Go只有for一个循环语句关键字，但支持3种形式
  - 初始化和步进表达式可以是多个值
  - 条件语句每次循环都会被重新检查，因此不建议在条件语句中
  - 使用函数，尽量提前计算好条件并以变量或常量代替
  - 左大括号必须和条件语句在同一行
## switch
- 选择语句switch
  - 可以使用任何类型或表达式作为条件语句
  - 不需要写break，一旦条件符合自动终止
  - 如希望继续执行下一个case，需使用fallthrough语句
  - 支持一个初始化表达式（可以是并行方式），右侧需跟分号
  - 左大括号必须和条件语句在同一行
## 跳转
- 跳转语句goto, break, continue
  - 三个语法都可以配合标签使用
  - 标签名区分大小写，若不使用会造成编译错误
  - Break与continue配合标签可用于多层循环的跳出
  - Goto是调整执行位置，与其它2个语句配合标签的结果并不相同
## 数组
- 数组Array
    - 定义数组的格式：var Name>[n]type，n>=0
    - 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型
    - 注意区分指向数组的指针和指针数组
    - 数组在Go中为值类型
    - 数组之间可以使用==或!=进行比较，但不可以使用<或>
    - 可以使用new来创建数组，此方法返回一个指向数组的指针
    - Go支持多维数组
## slice
- 切片Slice
    - 其本身并不是数组，它指向底层的数组
    - 作为变长数组的替代方案，可以关联底层数组的局部或全部
    - 为引用类型
    - 可以直接创建或从底层数组获取生成
    - 使用len()获取元素个数，cap()获取容量
    - 一般使用make()创建
    - 如果多个slice指向相同底层数组，其中一个的值改变会影响全部
    - make([]T, len, cap)
    - 其中cap可以省略，则和len的值相同
    - len表示存数的元素个数，cap表示容量


## defer

- defer的执行方式类似其它语言中的析构函数，在函数体执行结束后
- 按照调用顺序的相反顺序逐个执行
- 即使函数发生严重错误也会执行
- 支持匿名函数的调用
- 常用于资源清理、文件关闭、解锁以及记录时间等操作
- 通过与匿名函数配合可在return之后修改函数计算结果
- 如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer
- 时即已经获得了拷贝，否则则是引用某个变量的地址

- Go 没有异常机制，但有 panic/recover 模式来处理错误
- Panic 可以在任何地方引发，但recover只有在defer调用的函数中有效

## 结构struct


- Go 中的struct与C中的struct非常相似，并且Go没有class

- 使用 type Name struct{} 定义结构，名称遵循可见性规则

- 支持指向自身的指针类型成员

- 支持匿名结构，可用作成员或定义成员变量

- 匿名结构也可以用于map的值

- 可以使用字面值对结构进行初始化

- 允许直接通过指针来读写结构成员

- 相同类型的成员可进行直接拷贝赋值

- 支持 == 与 !=比较运算符，但不支持 > 或 <

- 支持匿名字段，本质上是定义了以某个类型名为名称的字段

- 嵌入结构作为匿名字段看起来像继承，但不是继承

- 可以使用匿名字段指针
## 方法method


- Go 中虽没有class，但依旧有method

- 通过显示说明receiver来实现与某个类型的组合

- 只能为同一个包中的类型定义方法

- Receiver 可以是类型的值或者指针

- 不存在方法重载

- 可以使用值或指针来调用方法，编译器会自动完成转换

- 从某种意义上来说，方法是函数的语法糖，因为receiver其实就是

- 方法所接收的第1个参数（Method Value vs. Method Expression）

- 如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法

- 类型别名不会拥有底层类型所附带的方法

- 方法可以调用结构中的非公开字段
## 接口interface


- 接口是一个或多个方法签名的集合

- 只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示

- 声明实现了哪个接口，这称为 Structural Typing

- 接口只有方法声明，没有实现，没有数据字段

- 接口可以匿名嵌入其它接口，或嵌入到结构中

- 将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个

- 复制品的指针，既无法修改复制品的状态，也无法获取指针

- 只有当接口存储的类型和对象都为nil时，接口才等于nil

- 接口调用不会做receiver的自动转换

- 接口同样支持匿名字段方法

- 接口也可实现类似OOP中的多态

- 空接口可以作为任何类型数据的容器
## 反射reflection


- 反射可大大提高程序的灵活性，使得 interface{} 有更大的发挥余地

- 反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息

- 反射会将匿名字段作为独立字段（匿名字段本质）

- 想要利用反射修改对象状态，前提是 interface.data 是 settable，

- 即 pointer-interface通过反射可以“动态”调用方法

<Valine></Valine>
