---
title: C++数据结构
date: 2019-3-17 16:17:45
categories: backEnd
tags:
- 后端
- C/C++
- 数据结构和算法
---
## C++
因为很多东西都在C中有，这里就只看看那些没有的
## 输入输出
### 一些规则
<strong>命名空间</strong><br/>
为了避免函数和变量名混乱我们使用命名空间来隔离开。调用的时候是`std::cout`使用了std空间里的cout函数<br/>
一般用std就够了。也可以直接using namespace std使用std下的所有东西。<br/>
<strong>头文件引入</strong><br/>
`#include < string >` c没有string，c++引入就有了，c中很多库需要加c前缀。 `<>`从系统头文件中寻找，没有则报错，`""`先从非系统头文件找，没有再找系统头文件，不会报错

### 标准IO
`#include < iostream >`标准输入输出流。在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据<br/>
cout是标准输出流对象插入到输出流中并输出到屏幕cout<<x<<endl;<br/>
cin是标准输入流对象，接受控制台输入的东西。cin>>x;<br/>
endl是尾部换行符（关于这个更多的google去吧，暂时用到这些）
### 文件IO
`#include < fstream >`文件输入输出流。
```c
ofstream oF("text.txt");//打开一个文件对象
oF<<333<<"aaaaa\n";//写入一个txt文件里
oF.close();//记得关掉
ifstream iF("text.txt");//输入一个文件对象的东西
double d;
string str;
iF>>d>>str;//接收变量
cout<<d<<""<<str//打印出来看看是啥
```
会txt就行了其他的不管了。
## 函数
### 默认参数
**引用变量**
>int a=3;
int &r=a;//r是a的引用变量

引用变量就是给变量起了个别名，指向同一块内存空间，定义的时候必须进行初始化而且必须保证类型匹配。引用变量定义之后就不能再更改指向其他人了。
<br/>主要做函数的形参。<br/>
c++的函数直接放进去是值传递`int f（int a,int b）{...}`调用f（x,y）不会对外部的x,y产生影响，因为函数自己开辟堆栈空间，ab只是复制了xy的值而没有真正拿到xy
<br/>
解决方法:
- 传入俩指针，在函数内部对指针里的值进行修改，直接对内存修改。`int f（int *a,int *b）{...}`调用f（&x,&y）<br/>
- 传入两个引用，不在函数内分配内存通过引用直接修改值。`int f（int &a,int &b）{...}`调用f（x,y）
**函数的默认参数**
参数可以有默认值的，`int f（char r,int x=3）`，**默认形参要靠右！**
### 函数重载
c++允许定义两个名字相同的函数，但**形参类型必须不要相同**，编译器会根据你传入的参数什么样子来调用不同的函数。
函数名和形参列表构成了函数签名，函数重载不能根据返回值来区分。注意歧义的情况。
```c
留坑
```
### 函数模板
上例中的两个函数可以用函数模板进行重构。数据类型变为模板类型参数。
template <typename T>定义了一个模板T
```c
留坑
```
:::warning
注意调用时给定的数据类型是否支持函数的操作。<br/>
在重载函数中也可以像函数模板一样指定类型。
:::
## 内存相关
指针和C是一样的,不懂的回去看。
### 动态内存管理
C++中使用`new`代替malloc。new除了分配内存外还会对对象进行初始化（new类对象的时候会调用构造函数等）。<br/>
`new`完了一定要`delete`如果没被delete那么这块被分配的内存会一直存在没有名字，不被回收造成内存泄漏。
```c
留坑
```
指针指向new出来的新数组的时候实质上是指向数组的首地址 
```c
留坑
```
:::danger
delete 掉new type[] 申请的内存必须要用**`delete[] p`**如果没有**`[]`**则只会删除数组的第一个元素值后面的元素会泄露
:::
## 面向对象
传统的面向过程编程，C++引入了面向对象编程OOP<a href='https://blog.csdn.net/it_man/article/details/6672964'>随便看一看吧后面再找个好的</a>
### 类和对象
面向对象编程：程序是由不同种类的许多对象相互协作完成的。对象之间通过发送/接收消息来协作完成各种任务。由这些对象构成的程序也称为“对象式系统".
<br/>**`class`** 定义类（你要非要用struct我也管不着）。类可以生成一个对象，类是对事物的特征抽象。通过类可以定义对象
访问的时候使用**`.`**。**对象**同样具有指针
看例子
```c
留坑
```
类对象可以通过指针来访问，访问符号为`->`
```c
class_name stu;//生成一个对象
class_name *object_pointer=&stu;//给指针赋值
object_pointer->name;//访问了属性
(*object_pointer).name;//访问了属性

class_name *object_pointer=new class_name;//给指针赋动态对象（存储在堆）
delete object_pointer//记得删除
```
成员可以有函数(行为)和变量(属性)。函数可以先在类中声明在后面实现。
### 访问控制
类中的成员默认为`private`只有本类中的成员才能调用，外部不能访问，声明一个类的时候通常要声明`public`和`private`.
<br/>**封装**<br/>
一般成员会设置为private，通过get/set方法进行设置和访问控制。
```c
留坑
```
### 构造析构
<br/>对象在生成的时候实际上是通过一个`构造函数`来生成的，构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void，如果不在类中定义，c++会默认给一个空的`默认构造函数`，啥都不执行。
<br/>构造函数可以用来初始化成员变量。构造函数可以提供参数，在声明对象的时候就要传入对应的参数。
<br/>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象(delete a;)时执行。
<br/>`析构函数`的名称与类的名称是完全相同的，只是在前面加波浪号`~`作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
```c
留坑
```
:::warning
自定义了构造函数之后不会再分配默认构造函数，也就不能直接声明对象数组。<br/>
student stu[3];会报错,存储指针或者用for添加进去
:::
### this指针
类中的成员函数自带了一个this指针。比如stu.print();==>print(&stu);把类的指针传入。
void print(student *this){<br/>
cout<<`this->name`<<""<<`this->score`<<end1;<br/>
}<br/>
### 继承
### 多态

### 运算符重载
### 类模板
### 接口(抽象类)