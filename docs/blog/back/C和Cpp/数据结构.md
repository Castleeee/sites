---
title: C++数据结构
date: 2019-3-17 16:17:45
categories: backEnd
tags:
- 后端
- C/C++
- 数据结构和算法
---
## C++
因为很多东西都在C中有，这里就只看看那些没有的
## 输入输出
### 一些规则
<strong>命名空间</strong><br/>
为了避免函数和变量名混乱我们使用命名空间来隔离开。调用的时候是`std::cout`使用了std空间里的cout函数<br/>
一般用std就够了。也可以直接using namespace std使用std下的所有东西。<br/>
<strong>头文件引入</strong><br/>
`#include < string >` c没有string，c++引入就有了，c中很多库需要加c前缀。 `<>`从系统头文件中寻找，没有则报错，`""`先从非系统头文件找，没有再找系统头文件，不会报错

### 标准IO
`#include < iostream >`标准输入输出流。在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据<br/>
cout是标准输出流对象插入到输出流中并输出到屏幕cout<<x<<endl;<br/>
cin是标准输入流对象，接受控制台输入的东西。cin>>x;<br/>
endl是尾部换行符（关于这个更多的google去吧，暂时用到这些）
### 文件IO
`#include < fstream >`文件输入输出流。
```c
ofstream oF("text.txt");//打开一个文件对象
oF<<333<<"aaaaa\n";//写入一个txt文件里
oF.close();//记得关掉
ifstream iF("text.txt");//输入一个文件对象的东西
double d;
string str;
iF>>d>>str;//接收变量
cout<<d<<""<<str//打印出来看看是啥
```
会txt就行了其他的不管了。
## 函数
### 默认参数
**引用变量**
>int a=3;
int &r=a;//r是a的引用变量

引用变量就是给变量起了个别名，指向同一块内存空间，定义的时候必须进行初始化而且必须保证类型匹配。引用变量定义之后就不能再更改指向其他人了。
<br/>主要做函数的形参。<br/>
c++的函数直接放进去是值传递`int f（int a,int b）{...}`调用f（x,y）不会对外部的x,y产生影响，因为函数自己开辟堆栈空间，ab只是复制了xy的值而没有真正拿到xy
<br/>
解决方法:
- 传入俩指针，在函数内部对指针里的值进行修改，直接对内存修改。`int f（int *a,int *b）{...}`调用f（&x,&y）<br/>
- 传入两个引用，不在函数内分配内存通过引用直接修改值。`int f（int &a,int &b）{...}`调用f（x,y）
**函数的默认参数**
参数可以有默认值的，`int f（char r,int x=3）`，**默认形参要靠右！**
### 函数重载
c++允许定义两个名字相同的函数，但**形参类型必须不要相同**，编译器会根据你传入的参数什么样子来调用不同的函数。
函数名和形参列表构成了函数签名，函数重载不能根据返回值来区分。注意歧义的情况。
```c
留坑
```
### 函数模板
上例中的两个函数可以用函数模板进行重构。数据类型变为模板类型参数。
template <typename T>定义了一个模板T
```c
留坑
```
:::warning
注意调用时给定的数据类型是否支持函数的操作。<br/>
在重载函数中也可以像函数模板一样指定类型。
:::

## 内存相关
指针和C是一样的,不懂的回去看。
### 动态内存管理
C++中使用`new`代替malloc。new除了分配内存外还会对对象进行初始化（new类对象的时候会调用构造函数等）。
`new`完了一定要`delete`如果没被delete那么这块被分配的内存会一直存在没有名字，不被回收造成内存泄漏。
```c
留坑
```
指针指向new出来的新数组的时候实质上是指向数组的首地址 
```c
留坑
```
:::danger
delete 掉new type[] 申请的内存必须要用**`delete[] p`**如果没有**`[]`**则只会删除数组的第一个元素值后面的元素会泄露
:::
## 面向对象
传统的面向过程编程，C++引入了面向对象编程OOP<a href='https://blog.csdn.net/it_man/article/details/6672964'>随便看一看吧后面再找个好的</a>
### 类和对象
面向对象编程：程序是由不同种类的许多对象相互协作完成的。对象之间通过发送/接收消息来协作完成各种任务。由这些对象构成的程序也称为“对象式系统".

### 封装
### 继承
### 多态

## 深入类和对象
### this指针
### 访问控制
### 构造析构
垃圾处理机制
### 运算符重载
### 类模板
### 接口(抽象类)    
不管元素是简单类型还是复杂类型，delete 掉new[] 申请的内存都会有内存泄漏