---
title: C++数据结构
date: 2019-3-17 16:17:45
categories: backEnd
tags:
- 后端
- C/C++
- 数据结构和算法
---
## C++
因为很多东西都在C中有，这里就只看看那些没有的
## 输入输出
### 一些规则
<strong>命名空间</strong><br/>
为了避免函数和变量名混乱我们使用命名空间来隔离开。调用的时候是`std::cout`使用了std空间里的cout函数<br/>
一般用std就够了。也可以直接using namespace std使用std下的所有东西。<br/>
<strong>头文件引入</strong><br/>
`#include < string >` c没有string，c++引入就有了，c中很多库需要加c前缀。 `<>`从系统头文件中寻找，没有则报错，`""`先从非系统头文件找，没有再找系统头文件，不会报错

### 标准IO
`#include < iostream >`标准输入输出流。在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据<br/>
cout是标准输出流对象插入到输出流中并输出到屏幕cout<<x<<endl;<br/>
cin是标准输入流对象，接受控制台输入的东西。cin>>x;<br/>
endl是尾部换行符（关于这个更多的google去吧，暂时用到这些）
### 文件IO
`#include < fstream >`文件输入输出流。
```c
ofstream oF("text.txt");//打开一个文件对象
oF<<333<<"aaaaa\n";//写入一个txt文件里
oF.close();//记得关掉
ifstream iF("text.txt");//输入一个文件对象的东西
double d;
string str;
iF>>d>>str;//接收变量
cout<<d<<""<<str//打印出来看看是啥
```
会txt就行了其他的不管了。
## 函数
### 默认参数
**引用变量**
>int a=3;
int &r=a;//r是a的引用变量

引用变量就是给变量起了个别名，指向同一块内存空间，定义的时候必须进行初始化而且必须保证类型匹配。引用变量定义之后就不能再更改指向其他人了。
<br/>主要做函数的形参。<br/>
c++的函数直接放进去是值传递`int f（int a,int b）{...}`调用f（x,y）不会对外部的x,y产生影响，因为函数自己开辟堆栈空间，ab只是复制了xy的值而没有真正拿到xy
<br/>
解决方法:
- 传入俩指针，在函数内部对指针里的值进行修改，直接对内存修改。`int f（int *a,int *b）{...}`调用f（&x,&y）<br/>
- 传入两个引用，不在函数内分配内存通过引用直接修改值。`int f（int &a,int &b）{...}`调用f（x,y）
**函数的默认参数**
参数可以有默认值的，`int f（char r,int x=3）`，**默认形参要靠右！**
### 函数重载
c++允许定义两个名字相同的函数，但**参数类型必须要不同**，编译器会根据你传入的参数什么样子来调用不同的函数。
### 引用变量
### 引用形参
### 函数模板
## 用户定义类型？？
## 内存相关
### 指针
### 动态内存管理
## 面向对象
### 类和对象
### 封装
### 继承
### 多态

## 深入类和对象
### this指针
### 访问控制
### 构造析构
垃圾处理机制
### 运算符重载
### 类模板
### 接口(抽象类)    
不管元素是简单类型还是复杂类型，delete 掉new[] 申请的内存都会有内存泄漏
